\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}
\usepackage{fancyhdr} \usepackage{graphicx,subfig} \usepackage{lastpage}
\usepackage{amssymb,amsmath} \usepackage{siunitx} \usepackage[nodayofweek]{datetime}
\usepackage[top=3.5cm,bottom=2.5cm,left=3cm,right=3cm,headheight=40pt]{geometry}
\usepackage{parskip} \usepackage{float} \usepackage{enumitem} \pagestyle{fancy}
\usepackage[colorlinks=true,allcolors=blue]{hyperref} \hypersetup{
	pdfauthor={Michaël Defferrard},
	pdftitle={Project stage 1: Terrain generation},
	pdfsubject={Introduction to Computer Graphics}
}

\lhead{Introduction to Computer Graphics\\Project stage 1: Terrain generation\\Group 19}
\chead{\hspace{2.5cm}EPFL\\\hspace{2.5cm}\shortdate\today\\\hspace{2.5cm}\thepage/\pageref{LastPage}}
\rhead{Michaël \textsc{Defferrard}\\Pierre \textsc{Fechting}\\Vu Hiep \textsc{Doan}}
\cfoot{}

\begin{document}


\section{Overview}

This report presents our advancement on the first part of the project : terrain generation using procedural methods. Figure~\ref{teaser} shows an example of what our actual code base is able to generate. All the minimal steps to display a procedurally generated terrain were successfully completed. We did also implement some other optional suggested methods, like the multifractal and the simple noise. We still plan to implement more.

\begin{figure}[ht]
	\centering
	\includegraphics[height=7cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed10}}}
	\caption{Example terrain generated by fractal Brownian motion with $H=1.1$, $l=10$ and 10 octaves, Perlin basis noise function.}
	\label{teaser}
\end{figure}

The main difficulties we did encounter during this first stage were about the framework. As for practicals and homeworks everything was set, we did not have any experience on the various functions used to create, bind or copy data into the various OpenGL object types. We took a lot of time to figure out how all this was working together. Now that we acquired some experience, the implementation of the next steps will surely be facilitated.

We did also loose time with some oddities. Let us give an example. The Perlin noise permutation table contains values from 0 to 255. It would thus make sense to store them as a \texttt{GL\_ubyte} array and to pass them to the shaders as a 1D texture of internal type \texttt{GL\_R8UI}. No data were however passed. The glsl \texttt{textureSize} built-in function was always returning a size of 0. After hours of trying to understand why a simple buffer copy does not work, we found a little note which said that standard compliant implementations do not have to exactly match the provided list of internal types and can fall back to other types\footnote{Explained on the OpenGL \href{https://www.opengl.org/wiki/GLAPI/glTexImage1D}{wiki}.}. After trying some other types like \texttt{GL\_R32I} we resigned and used \texttt{GL\_R32F} at the expense of 2 bytes per texel. The exact cause of this problem was however not elucidated.

As noted in the hand-out, we add to the fact that OpenGL debugging is hard and time-consuming. We use a lot of "black box" functions and debugging is not very practical. This is especially true for glsl and the infrastructure for data passing, as there is nothing until it works. At least at the beginning. When the infrastructure is in place and an output buffer is available, "printf debugging" can be used.

%We use git\footnote{the distributed revision control system} to manage our sources. Some members of the team were not familiar with source code management tools. It was a great to


\section{Implementation}

\subsection{Triangle grid}

We first generate the flat triangle mesh as a base for our terrain. The implementation is quite straightforward for a grid of size $N \times N$ as first, two VBOs storing the positions of each vertex and the corresponding faces' indices also are calculated.

We then render it as a triangle mesh by function \texttt{glDrawElements} to get a smooth triangle mesh (fig.~\ref{triangle_grid_full}). It is also worth noticing the use of \texttt{glPolygonMode}, which allows us to render only the triangles' boundaries as shown in figures~\ref{triangle_grid_8}, \ref{triangle_grid_16} and~\ref{triangle_grid_64} for $N=8$, $N=16$ and $N=64$, respectively.

\begin{figure}[ht]
	\centering
	\subfloat[Lines with $N=8$]{
		\label{triangle_grid_8}
		\includegraphics[height=4cm]{{{img_stage1/triangle_grid_8}}}
	} \quad
	\subfloat[Lines with $N=16$]{
		\label{triangle_grid_16}
		\includegraphics[height=4cm]{{{img_stage1/triangle_grid_16}}}
	} \quad
	\subfloat[Lines with $N=64$]{
		\label{triangle_grid_64}
		\includegraphics[height=4cm]{{{img_stage1/triangle_grid_64}}}
	} \quad
	\subfloat[Triangles]{
		\label{triangle_grid_full}
		\includegraphics[height=4cm]{{{img_stage1/triangle_grid_full}}}
	}
	\caption{Triangle grid}
	\label{triangle_grid}
\end{figure}

\subsection{Diffuse shading}

The terrain generated from displacing each vertex in base triangle grid according to height map will be applied the diffuse shading for better visualization. In short, each vertex will be colored by the result value of following equation: $I_dk_d(N\cdot L)$ where $I_d$ and $k_d$ is the diffuse color of the light source and material, respectively. $N$ is the normal vector at that vertex and $L$ is the normalized light direction vector.

We define te diffuse color of light source and material as well as the light position so except $N$, other values are very easy to compute. For calculating normal vector $N$, we use finite difference to approximate a gradient vectors $\nabla x$ and $\nabla y$ along \textit{x} and \textit{y} directions. Note that to compute theses gradients, we need the elevation at four neighboring vertices as well, which can be done again by looking up on the height map that we generated.

Then, the normal vector will be cross product of $\nabla x$ and $\nabla y$.

\subsection{Heightmap texture}

We did first construct an heightmap by hand (\texttt{gen\_test\_height\_map}) with a 3x3 pixels texture to test the displacement procedure of the rendering vertex shader and the height sensible coloring of the rendering fragment shader (fig.~\ref{test_heightmap}). We then implemented the texture rendering (\texttt{gen\_height\_map}). To test the framework, we rendered a simple texture of 1024x1024 pixels which all have the value of 0.5 (fig.~\ref{test_heightmap_gen}).

\begin{figure}[ht]
	\centering
	\subfloat[Heightmap constructed by hand]{
		\label{test_heightmap}
		\includegraphics[height=4cm]{{{img_stage1/test_heightmap}}}
	} \quad
	\subfloat[Simple generated heightmap]{
		\label{test_heightmap_gen}
		\includegraphics[height=4cm]{{{img_stage1/test_heightmap_gen}}}
	}
	\caption{Heightmaps}
\end{figure}

\subsection{Perlin noise}

We then implemented the Perlin noise in the heightmap fragment shader. As suggested by the tutorial\footnote{The GPU Gems 2 \href{http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html}{tutorial} given in the hand-out}, we used a permutation table to generate a pseudo-random number per square. The Fisher-Yates shuffle\footnote{Described on \href{https://en.wikipedia.org/wiki/Fisher-Yates}{Wikipedia}.}, also known as the Knuth shuffle is unbiased, as long as the underlying random generator is.

We use the \texttt{texelFetch} function to access the texture by its index instead of the normalized coordinate.

%Show some screenshots with different frequencies and amplitudes of the noise function.
%With / without zeros in gradients.

\subsection{Fractal Brownian movement}

Figure~\ref{fBm} shows the variety of procedural terrains that can be generated by an unique method, only by altering the seed of the pseudo-random number generator.

\begin{figure}[ht]
	\centering
	\subfloat[Seed of 2]{
		\includegraphics[height=3cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed2}}}
	} 
	\subfloat[Seed of 3]{
		\includegraphics[height=3cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed3}}}
	} 
	\subfloat[Seed of 4]{
		\includegraphics[height=3cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed4}}}
	} \\
	\subfloat[Seed of 5]{
		\includegraphics[height=3cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed5}}}
	} 
	\subfloat[Seed of 8]{
		\includegraphics[height=3cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed8}}}
	} 
	\subfloat[Seed of 10]{
		\includegraphics[height=3cm]{{{img_stage1/fBm_1.1_10.0_10_2.0_withZeroGrad_seed10}}}
	}
	\caption{Example of terrains generated by fractal Brownian motion with $H=1.1$, $l=10$ and 10 octaves, Perlin basis noise function. Different seeds were used to initialize the permutation table random shuffle.}
	\label{fBm}
\end{figure}

\subsection{Turbulence}

We also try to implement turbulence, which is very similar to fBm but use absolute value of noise instead. The result is shown in figure~\ref{turbulence}.

\begin{figure}[ht]
	\centering
	\includegraphics[height=4cm]{{{img_stage1/turbulence}}}
	\caption{Example of terrain generated by the turbulence method.}
	\label{turbulence}
\end{figure}
	
\subsection{Advanced topic : Multifractal}

As an enhancement to the fractal Brownian motion, we implemented the multifractal algorithm. to generate a terrain using Perlin basis noise function or Simplex basis noise function. Figures~\ref{multifractal_perlin} and \ref{multifractal_simplex} show examples of such generated terrain using Perlin and Simplex basis noise functions.

\begin{figure}[ht]
	\centering
	\subfloat[Perlin noise basis]{
		\label{multifractal_perlin}
		\includegraphics[height=4cm,width=6cm]{{{img_stage1/multifractal_perlin}}}
	} \quad
	\subfloat[Simplex noise basis]{
		\label{multifractal_simplex}
		\includegraphics[height=4cm,width=6cm]{{{img_stage1/multifractal_simplex}}}
	} 
	\caption{Example of terrains generated by the Multifractal method.}
	\label{multifractal}
\end{figure}

\subsection{Advanced topic : Simplex noise}

For Perlin noise, we leverage on a square grid (4 corners), which is sometimes unnecessary. Simplex noise, in contrary bases on a \textbf{simplex} grid, which in our 2D case is an equilateral triangles (see figure~\ref{simplexgrid}).

Since it would be very computationally expensive to find the position of three surrounding neighbors (colorfully encircled), we can skew the grid so that it can have the shape of square grid (Figure~\ref{skewdsimplexgrid}). Once we skew the grid, it would be every easy to find the triangle we are in by simple test of $x$ and $y$ coordinate (figure~\ref{findequilateral}).

\begin{figure}[ht]
	\centering
	\subfloat[Simplex grid]{
		\label{simplexgrid}
		\includegraphics[height=4cm]{{{img_stage1/simplex_grid}}}
	} \quad
	\subfloat[Skewed simplex grid]{
		\label{skewdsimplexgrid}
		\includegraphics[height=4cm]{{{img_stage1/simplex_grid_skewed}}}
	} \quad
		\subfloat[Determine current equilateral]{
			\label{findequilateral}
			\includegraphics[height=4cm]{{{img_stage1/xandy}}}
		}
	\caption{The simplex grid and its skewed version used for constructing Simplex noise.}
	\label{simplex_grid}
\end{figure}

After retrieving the coordinates of three surrounding corners, we use the same pseudo-random process as used in Perlin noise to look up for gradient of each corner. Then we find the contribution of each corner, which is proportional to the cube of the distance $(0.5 - x_d^2 - y_d^2)$. Here $x_d$ and $y_d$ is the difference in $x$ and $y$ axis from the corner to the position we are considering. Also, the proportional ratio is the dot product of the random gradient and the position vector.

Finally, we just sum up the contribution of each corner and scale it by some scalar (in our case is \textbf{80}).

Figure~\ref{simplex_noise} shows an example of a terrain generated by the implement simplex noise function.

\begin{figure}[ht]
	\centering
	\includegraphics[height=4cm]{{{img_stage1/simplex_noise}}}
	\caption{Example of terrain generated by simplex noise.}
	\label{simplex_noise}
\end{figure}


\section{Results}

Figure~\ref{texture} shows a closer look at the rendered triangle mesh.

\begin{figure}[ht]
	\centering
	\includegraphics[height=4cm]{{{img_stage1/texture}}}
	\caption{A closer look at the triangle mesh.}
	\label{texture}
\end{figure}


\end{document}
